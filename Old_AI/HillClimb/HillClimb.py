import random, math
from matplotlib import pyplot as plt


def percep(A, w, b, k, x):
    dot = 0
    for i in range(len(w)):
        dot += w[i] * x[i]
    return A(k, dot + b)


def sigmoid(k, z):
    return 1/ (1 + math.exp(-1 * k * z))


# Generates weight vectors, b values, and k values that apply to the network. Finally, the threshold value. These are all stored as tuples called "brains"
def gen_brain_4_1(w_min, w_max, b_min, b_max, k_min, k_max, t_min, t_max):
    brain = list()

    # Generate the weights list
    w = list()
    for x in range(12):
        w.append(random.uniform(w_min, w_max))
    brain.append(tuple(w))

    # Generate the b list
    b = list()
    for x in range(5):
        b.append(random.uniform(b_min, b_max))
    brain.append(tuple(b))

    # Generate the k list
    k = list()
    for x in range(5):
        k.append(random.uniform(k_min, k_max))
    brain.append(tuple(k))

    # Generate the threshold value
    brain.append((random.uniform(t_min, t_max),))

    return tuple(brain)

# Runs a brain on an input
def net_4_1(brain, input):
    percep_0 = percep(sigmoid, [brain[0][0], brain[0][1]], brain[1][0], brain[2][0], [input[0], input[1]])
    percep_1 = percep(sigmoid, [brain[0][2], brain[0][3]], brain[1][1], brain[2][1], [input[0], input[1]])
    percep_2 = percep(sigmoid, [brain[0][4], brain[0][5]], brain[1][2], brain[2][2], [input[0], input[1]])
    percep_3 = percep(sigmoid, [brain[0][6], brain[0][7]], brain[1][3], brain[2][3], [input[0], input[1]])
    percep_4 = percep(sigmoid, [brain[0][8], brain[0][9], brain[0][10], brain[0][11]], brain[1][4], brain[2][4],
                      [percep_0, percep_1, percep_2, percep_3])

    if percep_4 > brain[3][0]:
        return 1
    else:
        return 0


# Checks if a given input falls within a circle
def chec_circ(input):
    return 1 > (input[0] * input[0] + input[1] * input[1])


# Reads in the file that we are using as a training set
def read_coords(file):
    global training_set
    training_set = list()

    with open(file, "r") as f:
        for line in f:
            xs, ys = line.split()
            x, y = float(xs), float(ys)
            training_set.append(tuple(((x, y), chec_circ((x, y)))))
    training_set = tuple(training_set)


# This takes a brain and a network and gets the error
def test_brain(brain, network):
    total_error = 0
    for x in training_set:
        total_error += (x[1] - network(brain, x[0])) ** 2
    return total_error

# Plots a circle generated by a brain
def draw_brain(brain, network):
    coords = list()

    for x in range(1, 40):
        coords.append(-2 + x * .1)

    plt.axis([-2, 2, -2, 2])
    for x in coords:
        for y in coords:
            if chec_circ([x, y]):
                if network(brain, [x, y]) == 1:
                    plt.plot([x], [y], 'bo')
                else:
                    plt.plot([x], [y], 'co')
            else:
                if network(brain, [x, y]) == 1:
                    plt.plot([x], [y], 'mo')
                else:
                    plt.plot([x], [y], 'wo')

    plt.show()

# Attempts to train a network
def hill_climb(net_name, epsilon, messup_tol):
    while True: #This can be changed to a specific condition later
        if net_name == '4_1': # This checks the structure of the specific network you are using
            w = gen_brain_4_1(-1, 1, -1, 1, 0, 5, .5, .5)
            pre_err = test_brain(w, net_4_1)
            while pre_err >= 3504:
                w = gen_brain_4_1(-1, 1, -1, 1, 0, 5, .5, .5)
                pre_err = test_brain(w, net_4_1)
                print('Rand gen error: ' + str(pre_err))
            print()

            #Now that we have an initial brain
            mes_tally = 0
            while mes_tally < messup_tol:

                #I want some info when its about to die
                if mes_tally + 1 == messup_tol:
                    print()
                    print(w)
                    draw_brain(w, net_4_1)
                    print()

                # Generate a delta_w
                delta_w = list()

                for x in gen_brain_4_1(-1, 1, -1, 1, 0, 5, 0, .5):
                    temp = list()
                    for y in x:
                        temp.append(lam(pre_err) * y)
                    delta_w.append(tuple(temp))
                delta_w = tuple(delta_w)

                #Generate a w2
                w2 = list()
                for x in range(len(w)):
                    temp = list()
                    for y in range(len(w[x])):
                        temp.append(w[x][y] + delta_w[x][y])
                    w2.append(tuple(temp))
                w2 = tuple(w2)

                #See the new error
                # print(w2)
                # print(w)
                new_err = test_brain(w2, net_4_1)

                #Check for improvement
                # print('New_err: ' + str(new_err))
                # print('Pre_err: ' + str(pre_err))
                if new_err < pre_err:
                    w = w2
                    mes_tally = 0
                    pre_err = new_err
                    print('Current error: ' + str(new_err))
                else:
                    mes_tally += 1

                #Check if we have met out threshold
                if new_err < epsilon:
                    return w2

    print('This failed')
    return False

# This returns a lambda value depending on the error amount. This might need to be tweaked at some point.
def lam(error):
    # return 2 ** (error / 3000) - 1
    if error < 500:
        return .03
    else:
        return .05

read_coords('Old_AI/HillClimb/testing_vals')
hill_climb('4_1', 10, 1000)